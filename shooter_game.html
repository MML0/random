<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Shooter - Smooth Physics Movement</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: sans-serif;
      text-align: center;
      background: rgba(0, 0, 0, 0.6);
      padding: 20px;
      border-radius: 10px;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      background: white;
      border-radius: 50%;
      z-index: 100;
      pointer-events: none;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/examples/jsm/controls/PointerLockControls.js": "https://unpkg.com/three@0.165.0/examples/jsm/controls/PointerLockControls.js",
      "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
    }
  }
  </script>
</head>
<body>
  <div id="instructions">
    Click to play.<br>
    WASD to move, SPACE to jump, mouse to look, left click to shoot.
  </div>
  <div id="crosshair"></div>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/examples/jsm/controls/PointerLockControls.js";
    import * as CANNON from "cannon-es";

    // ---------- Scene ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5); // Natural eye height

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ---------- Lights ----------
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);

    const directional = new THREE.DirectionalLight(0xffffff, 0.8);
    directional.position.set(10, 20, 10);
    directional.castShadow = true;
    directional.shadow.mapSize.set(1024, 1024);
    directional.shadow.camera.near = 0.5;
    directional.shadow.camera.far = 50;
    scene.add(directional);



    // ---------- Physics World ----------
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.solver.iterations = 10;

    // --- Materials ---
    const playerMaterial = new CANNON.Material("playerMat");
    const floorMaterial = new CANNON.Material("floorMat");

    // --- Contact with zero friction ---
    const contactMat = new CANNON.ContactMaterial(playerMaterial, floorMaterial, {
    friction: 0,      // disable friction
    restitution: 0.0  // no bounce
    });
    world.addContactMaterial(contactMat);

    // Floor
    const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
    floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    // Assign floor material
    floorBody.material = floorMaterial;
    world.addBody(floorBody);

    const floorMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(50, 50),
      new THREE.MeshStandardMaterial({ color: 0x888888 })
    );
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    // ---------- Walls / Beam ----------
    function addWall(pos, size) {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(size.x, size.y, size.z),
        new THREE.MeshStandardMaterial({ color: 0x555555 })
      );
      mesh.position.copy(pos);
      mesh.receiveShadow = true;
      scene.add(mesh);

      const body = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2))
      });
      body.position.copy(pos);
      world.addBody(body);
    }

    addWall(new THREE.Vector3(0, 2, -10), new THREE.Vector3(20, 4, 1));
    addWall(new THREE.Vector3(-10, 2, 0), new THREE.Vector3(1, 4, 20));
    addWall(new THREE.Vector3(10, 2, 0), new THREE.Vector3(1, 4, 20));
    addWall(new THREE.Vector3(0, 2, 10), new THREE.Vector3(20, 4, 1));
    addWall(new THREE.Vector3(0, 0.5, 0), new THREE.Vector3(5, 1, 1)); // central beam

    // ---------- Cubes (Interactive Targets) ----------
    const cubeMeshes = [];
    const cubeBodies = [];
    const cubeSize = 1;
    const cubeCount = 30;

    for (let i = 0; i < cubeCount; i++) {
      const color = Math.random() * 0xffffff;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize),
        new THREE.MeshStandardMaterial({ color })
      );
      mesh.position.set(
        (Math.random() - 0.5) * 20,
        1 + Math.random() * 5,
        (Math.random() - 0.5) * 20
      );
      mesh.castShadow = true;
      scene.add(mesh);
      cubeMeshes.push(mesh);

      const body = new CANNON.Body({
        mass: 1,
        shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),
        position: new CANNON.Vec3(mesh.position.x, mesh.position.y, mesh.position.z),
        linearDamping: 0.4,
        angularDamping: 0.4
      });
      world.addBody(body);
      cubeBodies.push(body);
    }



    // ---------- Player Physics Body ----------
    // const playerHeight = 1.6;
    // const playerRadius = 0.7; // Realistic width

    // const playerShape = new CANNON.Sphere(playerRadius);
    // const playerBody = new CANNON.Body({
    //   mass: 5,
    //   linearDamping: 0.5,
    //   angularDamping: 0.5
    // });
    // playerBody.addShape(playerShape);
    // playerBody.position.set(0, playerHeight, 5);
    // world.addBody(playerBody);

const playerHeight = 1.6;
const playerRadius = 0.3;

const playerShape = new CANNON.Cylinder(playerRadius, playerRadius, playerHeight, 8);
const playerBody = new CANNON.Body({
  mass: 5,
  linearDamping: 0.5,
  angularDamping: 0, // prevents wobble,
    material: playerMaterial
});
playerBody.addShape(playerShape);
playerBody.position.set(0, playerHeight / 2, 5);
playerBody.fixedRotation = true; // don't tip over
playerBody.updateMassProperties();
world.addBody(playerBody);


    // Ground detection
    let isOnGround = false;
    world.addEventListener("contact", (event) => {
      const { bodyA, bodyB } = event;
      if (
        (bodyA === playerBody && bodyB === floorBody) ||
        (bodyB === playerBody && bodyA === floorBody)
      ) {
        isOnGround = true;
      }
    });

    // ---------- Controls ----------
    const controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener("click", () => {
      controls.lock();
      document.getElementById("instructions").style.display = "none";
    });

    const keys = { w: false, a: false, s: false, d: false, space: false, m: false };
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (key in keys) keys[key] = true;
    });
    document.addEventListener("keyup", (e) => {
      const key = e.key.toLowerCase();
      if (key in keys) keys[key] = false;
    });
    document.addEventListener("keydown", e => {
  if(e.code === "Space") keys.space = true;
  if(e.key.toLowerCase() === "m") keys.m = true;
});

document.addEventListener("keyup", e => {
  if(e.code === "Space") keys.space = false;
  if(e.key.toLowerCase() === "m") keys.m = false;
});


    // ---------- Bullets ----------
    const bullets = [];
    function shoot() {
      const bulletGeo = new THREE.SphereGeometry(0.05, 8, 8);
      const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
      const mesh = new THREE.Mesh(bulletGeo, bulletMat);

      // Get camera position and direction
      const pos = new THREE.Vector3();
      controls.getObject().getWorldPosition(pos);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      // Offset bullet forward so it doesn't spawn inside player
      const offset = 0.5;
      const spawnPos = pos.clone().add(dir.clone().multiplyScalar(offset));
      mesh.position.copy(spawnPos);
      scene.add(mesh);

      // Physics body
      const body = new CANNON.Body({
        mass: 0.1,
        shape: new CANNON.Sphere(0.08),
        position: new CANNON.Vec3(spawnPos.x, spawnPos.y, spawnPos.z)
      });

      const shootPower = 30;
      body.velocity.set(dir.x * shootPower, dir.y * shootPower, dir.z * shootPower);
      body.linearDamping = 0;
      world.addBody(body);

      bullets.push({ mesh, body, life: 120 });
    }
    document.addEventListener("mousedown", shoot);
    
    // setInterval(shoot,2)
    // ---------- Animation Loop ----------
    const timeStep = 1 / 60;
    const maxSpeed = 6;
    const acceleration = 0.15; // 0 = slow, 1 = instant
    let canJump = true;

// let isOnGround = false;

function checkGround() {
  // Raycast from the bottom of the player (feet) straight down
  const rayFrom = new CANNON.Vec3(
    playerBody.position.x,
    playerBody.position.y - playerHeight / 2 - playerRadius-.05, // Feet position
    playerBody.position.z
  );

  const rayTo = new CANNON.Vec3(
    playerBody.position.x,
    playerBody.position.y - playerHeight / 2 - playerRadius - 0.6, // 0.6 units down
    playerBody.position.z
  );

    const result = new CANNON.RaycastResult();
    const hit = world.rayTest(rayFrom, rayTo, result);
    console.log(result.hasHit);
    
    return result.hasHit;
    
    }


    function animate() {
      requestAnimationFrame(animate);

      // Jump


    // if ((keys.space || keys.m) && canJump && checkGround()) {
    if ((keys.space || keys.m) && canJump ) {
    playerBody.velocity.y = 7; // reasonable jump
    canJump = false;
    setTimeout(() => (canJump = true), 2000);
    }

      // --- Smooth Movement with Camera Direction ---
      const input = new THREE.Vector3(0, 0, 0);
      if (keys.w) input.z -= 1;
      if (keys.s) input.z += 1;
      if (keys.a) input.x -= 1;
      if (keys.d) input.x += 1;

      const currentVelocity = new THREE.Vector3(
        playerBody.velocity.x,
        0,
        playerBody.velocity.z
      );

      if (input.length() > 0) {
        input.normalize();

        // Get camera's forward and right vectors (XZ plane)
        const front = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

        // Build world-space movement vector
        const target = new THREE.Vector3()
          .addScaledVector(right, input.x)
          .addScaledVector(front, input.z)
          .normalize()
          .multiplyScalar(maxSpeed);

        // Accelerate toward target velocity
        playerBody.velocity.x += (target.x - currentVelocity.x) * acceleration;
        playerBody.velocity.z += (target.z - currentVelocity.z) * acceleration;
      } else {
        // Apply friction when no input
        const friction = 0.92;
        playerBody.velocity.x *= friction;
        playerBody.velocity.z *= friction;
      }

      // Sync camera position to physics body
      camera.position.copy(playerBody.position);

      // Step physics
      world.step(timeStep);

      // Update cubes
      for (let i = 0; i < cubeMeshes.length; i++) {
        cubeMeshes[i].position.copy(cubeBodies[i].position);
        cubeMeshes[i].quaternion.copy(cubeBodies[i].quaternion);
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.copy(b.body.position);
        b.mesh.quaternion.copy(b.body.quaternion);
        b.life--;

        if (b.life <= 0) {
          world.removeBody(b.body);
          scene.remove(b.mesh);
          bullets.splice(i, 1);
        }
      }

      // Render
      renderer.render(scene, camera);
    }

    animate();

    // Resize handler
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>